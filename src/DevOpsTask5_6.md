### Домашнее задание 5-6

# Задание 1
    
Архитектор ПО решил проконсультироваться у вас, какой тип БД лучше выбрать для хранения определенных данных.

Он вам предоставил следующие типы сущностей, которые нужно будет хранить в БД:

    Электронные чеки в json виде
    Склады и автомобильные дороги для логистической компании
    Генеалогические деревья
    Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации
    Отношения клиент-покупка для интернет-магазина

Выберите подходящие типы СУБД для каждой сущности и объясните свой выбор.

# Решение 1
    
    Электронные чеки в json виде
        Идеально подойдут нереляционные БД MongoDB или Redis в реализации CP по теореме CAP и PA-EC по теореме PACELC.
        Cosistency (согласованность) - для недопущения ошибок, ведь никтобы не хотел вместо чека на майбах, получить чек за мороженку.
        Partition tolerance (устойчивость к разделению) - для надежности, ведь потерять чеки клиентов будет крайне неприятной ситуацией.
        Availability (доступность) - нам важно не потерять информацию о чеке, чем получить чек как можно скорее.

    Склады и автомобильные дороги для логистической компании
        Тут выбор точно в нереляционные БД MongoDB или Redis, а именно в решение с графами, так как склады это узлы, а дороги это связь между ними.
        В реализации CP по теореме CAP и PA-EC по теореме PACELC.
        Cosistency (согласованность) - для недопущения ошибок, ведь никтобы не хотел лишний раз гонять товар между узлами.
        Partition tolerance (устойчивость к разделению) - для надежности, ведь потерять данные со склада остановит всю работу и придется заново все инвентаризировать.
        Availability (доступность) - нам важно не потерять информацию о нашей системе, чем получить ответ по логистике.

    Генеалогические деревья
        Аналогично выбор за нереляционными БД MongoDB или Redis, которые используют в своей структуре иерархическую систему.
        В реализации CP по теореме CAP и PA-EC по теореме PACELC, так как нам важно не потерять её, а скорость нам не важна.

    Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации
        Аналогично выбор за нереляционными БД PNUTS, которые используют в своей структуре Ключ-значение.
        В реализации CA по теореме CAP, а по теореме PACELC это будет EL-PC.
        Cosistency (согласованность) - для недопущения ошибок, ведь никтобы не хотел чтобы клиент получил не свой кеш идентификатора.
        Latency (время) - для скорости, ведь потерять данные хешей не критично - их можно восстановить, а хэш не живет долго.

    Отношения клиент-покупка для интернет-магазина
        Тут недостаточно контекста.

        Если рассматривать клиент-покупка как отдельную БД
            То выбор за нереляционными БД PNUTS, которые используют в своей структуре Ключ-значения. 
            Ключ - уникальный идентификатор клиента.
            Значения, список уникальных идентификаторов товара и их количество.
            В реализации CA по теореме CAP, а по теореме PACELC это будет EL-PC.
            Cosistency (согласованность) - для недопущения ошибок, ведь никтобы не хотел чтобы клиент получил не свой товар.
            Latency (время) - для скорости, ведь магазинов работающих быстрее много, а потерять данные заказа не критично - их можно повторить.

        Если рассматривать клиент-покупка как таблицы внутри какой-то БД
            Выбор за реляционными БД Postgres MySQL, которые будут использовать кучу связей: данные о клиенте и его скидке, 
            склада и наличия товара, цен на товары и скидки, логистику по доставке и получению.
            В реализации CP по теореме CAP и PA-EC по теореме PACELC.
            Cosistency (согласованность) - для недопущения ошибок, ведь никтобы не хотел перепутать заказы.
            Partition tolerance (устойчивость к разделению) - для надежности, ведь потерять данные со о заказах и оплатах.
            Availability (доступность) - нам важно не потерять информацию о нашей системе, чем получить ответ по логистике.

# Задание 2

Вы создали распределенное высоконагруженное приложение и хотите классифицировать его согласно CAP-теореме. Какой классификации по CAP-теореме соответствует ваша система, если (каждый пункт - это отдельная реализация вашей системы и для каждого пункта надо привести классификацию):

    Данные записываются на все узлы с задержкой до часа (асинхронная запись)
    При сетевых сбоях, система может разделиться на 2 раздельных кластера
    Система может не прислать корректный ответ или сбросить соединение

А согласно PACELC-теореме, как бы вы классифицировали данные реализации?

# Решение 2

    Данные записываются на все узлы с задержкой до часа (асинхронная запись)
        В реализации CP по теореме CAP и PA-EC по теореме PACELC.
        Cosistency (согласованность) - для недопущения ошибок.
        Partition tolerance (устойчивость к разделению) - для надежности.
        Availability (доступность) - нам гарантировано получить информацию, а для записи есть час.

    При сетевых сбоях, система может разделиться на 2 раздельных кластера
        В реализации CP по теореме CAP и PA-EC или EC-PC по теореме PACELC в зависимости от требований к согласованности.
        Cosistency (согласованность) - для недопущения ошибок.
        Partition tolerance (устойчивость к разделению) - для надежности.
        Availability (доступность) - нам гарантировано получить информацию на оба узла.

    Система может не прислать корректный ответ или сбросить соединение
        CAP теорема тут не очень применима, а по теореме PACELC PA-EL.
        Latency (время) - для скорости, ведь можно и сбросить соединение.
        Availability (доступность) - если ответ может быть неверным, то пускай наша система будет более доступна.

# Задание 3

    Могут ли в одной системе сочетаться принципы BASE и ACID? Почему?

# Решение 3

    Полность сочетаться BASE и ACID не могут, но возможны какие-то компромисы или промежуточные решения.
    Сочетаться полностью BASE и ACID не могут, потому что BASE говорит о скорости и доступности, а ACID о согласованности 
    и стойкости (в плане разделения для резервирования).

    Так как CAP теорема говорит нам о том, что мы можем выбрать только 2 значения из трёх:
        - BASE-доступность,
        - ACID-согласованность,
        - ACID-стойкости (в плане разделения для резервирования).
    То получается, что мы по CAP теореме не сможем их сочетать, если стойкость идёт в плане разделения для резервирования.

    Конечно, если система может достигать стойкости не через разделение для резервирования, то BASE и ACID могут сочетаться 
    по теореме CAP через CA. Но это скорее исключение.

    В теореме PACELC добавится BASE-скорость (Latency - время) и получается, что уже нужно выбрать 2 из 4х приципов и тут 
    даже без учета стойкости выбрать не получиться.

    Но в реальной жизни не бывает чего-то идеального, то конечно можно сделать систему, которая не будет до конца соответствовать 
    BASE и ACID, но в то же время будет в какой-то мере выполнять принцыпы обоих.
    Все же понятия относительны:
        Какое должно быть время отклика час или год?
        Какая должна быть стойкость резервное копирование или чтобы сервер не украли из стойки?
    Как минимум на бумаге это будет прописано, она же всё стерпит) А вот метрики у такой системы не будут соответствовать ни BASE ни ACID((

# Задание 4

    Вам дали задачу написать системное решение, основой которого бы послужили:

    фиксация некоторых значений с временем жизни
    реакция на истечение таймаута

    Вы слышали о key-value хранилище, которое имеет механизм Pub/Sub. Что это за система? Какие минусы выбора данной системы?

# Решение 4

    Pub/Sub это Publish/ Subscribe система, которая может передавать о себе информацию и подписываться на рассылки. 
    Например, Redis может поддерживать хранилище типов данных key-value и имеет уже встроенный функционал Pub/Sub. 
    То есть имеет из коробки весь необходимый для нашей задачи функционал. Не нужно запускать в daemon скрипты или делать 
    самописные контейнеры, которые будут проверять время жизни. А достаточно сформировать в Redis хранилище key-value и 
    настроить Pub/Sub на скрипт с проверкой времени жизни и в случае его истечения удалением этого значения.
    Но Redis не гарантирует консистентности, то есть не гарантирует, что ответ дойдет.
